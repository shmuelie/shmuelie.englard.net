{"version":3,"sources":["blog/render.ts","blog/render.js"],"names":["DOM","FASTElementDefinition","html","HTMLDirective","Observable","isFunction","object","isString","RenderBehavior","constructor","location","dataBinding","templateBinding","this","source","view","data","originalContext","childContext","dataBindingObserver","binding","templateBindingObserver","bind","context","Object","create","parent","parentContext","observe","template","refreshView","unbind","isComposed","needsBindOnly","disconnect","handleChange","$fastTemplate","remove","insertBefore","RenderDirective","super","createPlaceholder","createBlockPlaceholder","createBehavior","target","isElementRenderOptions","element","tagName","typeToInstructionLookup","Map","defaultAttributes","x","brand","Symbol","defaultViewName","nullTemplate","instructionToTemplate","def","createElementTemplate","attributes","content","markup","values","attrNames","getOwnPropertyNames","i","ii","length","name","push","options","_a","_b","forType","Error","type","instanceOf","register","optionsOrInstruction","lookup","get","set","instruction","getByType","entries","getForInstance","RenderInstruction","freeze","renderWith","value","NodeTemplate","node","_","__","refNode","parentNode","removeChild","render","templateOrTemplateBindingOrViewName","Node","s","c","result"],"mappings":"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","file":"render.js","sourcesContent":["// From https://github.com/microsoft/fast/issues/6114\n// https://gist.github.com/EisenbergEffect/281efd9ae96ad1439f2eb95ee745fd47\n\nimport {\n    Behavior,\n    Binding,\n    BindingObserver,\n    CaptureType,\n    Constructable,\n    DOM,\n    ExecutionContext,\n    FASTElement,\n    FASTElementDefinition,\n    html,\n    HTMLDirective,\n    Observable,\n    Subscriber,\n    SyntheticViewTemplate,\n    TemplateValue,\n    ViewTemplate\n} from 'https://unpkg.com/@microsoft/fast-element@1.14.0';\n\nconst isFunction = (object: any): object is Function => typeof object === \"function\";\nconst isString = (object: any): object is string => typeof object === \"string\";\n\n/**\n * A simple View that can be interpolated into HTML content.\n * @public\n */\n export interface ContentView {\n    /**\n    * Binds a view's behaviors to its binding source.\n    * @param source - The binding source for the view's binding behaviors.\n    * @param context - The execution context to run the view within.\n    */\n    bind(source: any, context: ExecutionContext): void;\n\n    /**\n    * Unbinds a view's behaviors from its binding source and context.\n    */\n    unbind(): void;\n\n    /**\n    * Inserts the view's DOM nodes before the referenced node.\n    * @param node - The node to insert the view's DOM before.\n    */\n    insertBefore(node: Node): void;\n\n    /**\n    * Removes the view's DOM nodes.\n    * The nodes are not disposed and the view can later be re-inserted.\n    */\n    remove(): void;\n}\n\n/**\n* A simple template that can create ContentView instances.\n* @public\n*/\nexport interface ContentTemplate {\n  /**\n   * Creates a simple content view instance.\n   */\n  create(): ContentView;\n}\n\ntype ComposableView = ContentView & {\n    isComposed?: boolean;\n    needsBindOnly?: boolean;\n    $fastTemplate?: ContentTemplate;\n};\n\n/**\n * A Behavior that enables advanced rendering.\n * @public\n */\nexport class RenderBehavior<TSource = any>\n    implements Behavior, Subscriber {\n    private source: TSource | null = null;\n    private view: ComposableView | null = null;\n    private template!: ContentTemplate;\n    private templateBindingObserver: BindingObserver<TSource, ContentTemplate>;\n    private data: any | null = null;\n    private dataBindingObserver: BindingObserver<TSource, any[]>;\n    private originalContext: ExecutionContext | undefined = void 0;\n    private childContext: ExecutionContext | undefined = void 0;\n\n    /**\n     * Creates an instance of RenderBehavior.\n     * @param location - A Node representing the location where this behavior will render.\n     * @param dataBinding - A binding expression that returns the data to render.\n     * @param templateBinding - A binding expression that returns the template to use with the data.\n     */\n    public constructor(\n        private location: Node,\n        private dataBinding: Binding<TSource, any[]>,\n        private templateBinding: Binding<TSource, ContentTemplate>\n    ) {\n        this.dataBindingObserver = Observable.binding(dataBinding, this, true);\n        this.templateBindingObserver = Observable.binding(templateBinding, this, true);\n    }\n\n    /**\n     * Bind this behavior to the source.\n     * @param source - The source to bind to.\n     * @param context - The execution context that the binding is operating within.\n     */\n    public bind(source: TSource, context: ExecutionContext): void {\n        this.source = source;\n        this.originalContext = context;\n        this.childContext = Object.create(context);\n        this.childContext!.parent = source;\n        (this.childContext! as any).parentContext = this.originalContext;\n        this.data = this.dataBindingObserver.observe(source, this.originalContext);\n        this.template = this.templateBindingObserver.observe(\n            source,\n            this.originalContext\n        );\n\n        this.refreshView();\n    }\n\n    /**\n     * Unbinds this behavior from the source.\n     * @param source - The source to unbind from.\n     */\n    public unbind(): void {\n        this.source = null;\n        this.data = null;\n\n        const view = this.view;\n\n        if (view !== null && view.isComposed) {\n            view.unbind();\n            view.needsBindOnly = true;\n        }\n\n        this.dataBindingObserver.disconnect();\n        this.templateBindingObserver.disconnect();\n    }\n\n    /** @internal */\n    public handleChange(source: any): void {\n        if (source === this.dataBinding) {\n            this.data = this.dataBindingObserver.observe(\n                this.source!,\n                this.originalContext!\n            );\n\n            this.refreshView();\n        } else if (source === this.templateBinding) {\n            this.template = this.templateBindingObserver.observe(\n                this.source!,\n                this.originalContext!\n            );\n\n            this.refreshView();\n        }\n    }\n\n    private refreshView() {\n        let view = this.view;\n        const template = this.template;\n\n        if (view === null) {\n            this.view = view = template.create();\n        } else {\n            // If there is a previous view, but it wasn't created\n            // from the same template as the new value, then we\n            // need to remove the old view if it's still in the DOM\n            // and create a new view from the template.\n            if (view.$fastTemplate !== template) {\n                if (view.isComposed) {\n                    view.remove();\n                    view.unbind();\n                }\n\n                this.view = view = template.create();\n            }\n        }\n\n        // It's possible that the value is the same as the previous template\n        // and that there's actually no need to compose it.\n        if (!view.isComposed) {\n            view.isComposed = true;\n            view.bind(this.data, this.childContext!);\n            view.insertBefore(this.location);\n            view.$fastTemplate = template;\n        } else if (view.needsBindOnly) {\n            view.needsBindOnly = false;\n            view.bind(this.data, this.childContext!);\n        }\n    }\n}\n\n/**\n * A Directive that enables use of the RenderBehavior.\n * @public\n */\nexport class RenderDirective<TSource = any> extends HTMLDirective {\n\n\n    /**\n     * Creates an instance of RenderDirective.\n     * @param dataBinding - A binding expression that returns the data to render.\n     * @param templateBinding - A binding expression that returns the template to use to render the data.\n     */\n    public constructor(\n        public readonly dataBinding: Binding,\n        public readonly templateBinding: Binding<TSource, ContentTemplate>\n    ) {\n      super()\n    }\n\n    public createPlaceholder: (index: number) => string = DOM.createBlockPlaceholder;\n\n    /**\n     * Creates a behavior.\n     * @param targets - The targets available for behaviors to be attached to.\n     */\n    public createBehavior(target: Node): RenderBehavior<TSource> {\n        return new RenderBehavior<TSource>(\n            target,\n            this.dataBinding,\n            this.templateBinding\n        );\n    }\n}\n\n/**\n * Provides instructions for how to render a type.\n * @public\n */\nexport interface RenderInstruction {\n    /**\n     * Identifies this as a RenderInstruction.\n     */\n    brand: symbol;\n    /**\n     * The type this instruction is associated with.\n     */\n    type: Constructable;\n    /**\n     * The template to use when rendering.\n     */\n    template: ContentTemplate;\n    /**\n     * A name that can be used to identify the instruction.\n     */\n    name: string;\n}\n\n/**\n * Render options that are common to all configurations.\n * @public\n */\nexport type CommonRenderOptions = {\n    /**\n     * The type this instruction is associated with.\n     */\n    type: Constructable;\n    /**\n     * A name that can be used to identify the instruction.\n     */\n    name?: string;\n};\n\n/**\n * Render options used to specify a template.\n * @public\n */\nexport type TemplateRenderOptions = CommonRenderOptions & {\n    /**\n     * The template to use when rendering.\n     */\n    template: ContentTemplate;\n};\n\n/**\n * Render options that are common to all element render instructions.\n * @public\n */\nexport type BaseElementRenderOptions<\n    TSource = any,\n    TParent = any\n> = CommonRenderOptions & {\n    /**\n     * Attributes to use when creating the element template.\n     */\n    attributes?: Record<string, string | TemplateValue<TSource, TParent>>;\n    /**\n     * Content to use when creating the element template.\n     */\n    content?: string | SyntheticViewTemplate;\n};\n\n/**\n * Render options used to specify an element.\n * @public\n */\nexport type ElementConstructorRenderOptions<\n    TSource = any,\n    TParent = any\n> = BaseElementRenderOptions<TSource, TParent> & {\n    /**\n     * The element to use when rendering.\n     */\n    element: Constructable<FASTElement>;\n};\n\n/**\n * Render options use to specify an element by tag name.\n * @public\n */\nexport type TagNameRenderOptions<TSource = any, TParent = any> = BaseElementRenderOptions<\n    TSource,\n    TParent\n> & {\n    /**\n     * The tag name to use when rendering.\n     */\n    tagName: string;\n};\n\ntype ElementRenderOptions<TSource = any, TParent = any> =\n    | TagNameRenderOptions<TSource, TParent>\n    | ElementConstructorRenderOptions<TSource, TParent>;\n\nfunction isElementRenderOptions(object: any): object is ElementRenderOptions {\n    return !!object.element || !!object.tagName;\n}\n\nconst typeToInstructionLookup = new Map<\n    Constructable,\n    Record<string, RenderInstruction>\n>();\n\n/* eslint @typescript-eslint/naming-convention: \"off\"*/\nconst defaultAttributes = { \":model\": (x: any) => x };\nconst brand = Symbol(\"RenderInstruction\");\nconst defaultViewName = \"default-view\";\nconst nullTemplate = html`\n    &nbsp;\n`;\n\nfunction instructionToTemplate(def: RenderInstruction | undefined) {\n    if (def === void 0) {\n        return nullTemplate;\n    }\n\n    return def.template;\n}\n\nfunction createElementTemplate<TSource = any, TParent = any>(\n    tagName: string,\n    attributes?: Record<string, string | TemplateValue<TSource, TParent>>,\n    content?: string | ContentTemplate\n): ViewTemplate<TSource, TParent> {\n    const markup = attributes ? [`<${tagName}`] : [`<${tagName}>`];\n    const values: Array<TemplateValue<TSource, TParent>> = [];\n\n    if (attributes) {\n      const attrNames = Object.getOwnPropertyNames(attributes);\n\n      for (let i = 0, ii = attrNames.length; i < ii; ++i) {\n        const name = attrNames[i];\n\n        if (i === 0) {\n          markup[0] = `${markup[0]} ${name}=\"`;\n        } else {\n          markup.push(`\" ${name}=\"`);\n        }\n\n        values.push(attributes[name]);\n      }\n\n      if (content && isFunction((content as any).create)) {\n        markup.push(`\">`);\n        values.push(content);\n        markup.push(`</${tagName}>`);\n      } else {\n        markup.push(`\">${content ?? ''}</${tagName}>`);\n      }\n    } else if (content && isFunction((content as any).create)) {\n      values.push(content);\n      markup.push(`</${tagName}>`);\n    } else {\n      markup[0] = `${markup[0]}${content}</${tagName}>`;\n    }\n\n    return html(markup as any as TemplateStringsArray, ...values);\n}\n\nfunction create(options: TagNameRenderOptions): RenderInstruction;\nfunction create(options: ElementConstructorRenderOptions): RenderInstruction;\nfunction create(options: TemplateRenderOptions): RenderInstruction;\nfunction create(options: any): RenderInstruction {\n    const name = options.name ?? defaultViewName;\n    let template: ContentTemplate;\n\n    if (isElementRenderOptions(options)) {\n        let tagName = (options as TagNameRenderOptions).tagName;\n\n        if (!tagName) {\n            const def = FASTElementDefinition.forType(\n                (options as ElementConstructorRenderOptions).element\n            );\n\n            if (def) {\n                tagName = def.name;\n            } else {\n                throw new Error(\"Invalid element for model rendering.\");\n            }\n        }\n\n        template = createElementTemplate(\n            tagName,\n            options.attributes ?? defaultAttributes,\n            options.content\n        );\n    } else {\n        template = options.template;\n    }\n\n    return {\n        brand,\n        type: options.type,\n        name,\n        template,\n    };\n}\n\nfunction instanceOf(object: any): object is RenderInstruction {\n    return object && object.brand === brand;\n}\n\nfunction register(options: TagNameRenderOptions): RenderInstruction;\nfunction register(options: ElementConstructorRenderOptions): RenderInstruction;\nfunction register(options: TemplateRenderOptions): RenderInstruction;\nfunction register(instruction: RenderInstruction): RenderInstruction;\nfunction register(optionsOrInstruction: any): RenderInstruction {\n    let lookup = typeToInstructionLookup.get(optionsOrInstruction.type);\n    if (lookup === void 0) {\n        typeToInstructionLookup.set(\n            optionsOrInstruction.type,\n            (lookup = Object.create(null) as {})\n        );\n    }\n\n    const instruction = instanceOf(optionsOrInstruction)\n        ? optionsOrInstruction\n        : create(optionsOrInstruction);\n\n    return (lookup[instruction.name] = instruction);\n}\n\nfunction getByType(type: Constructable, name?: string): RenderInstruction | undefined {\n    const entries = typeToInstructionLookup.get(type);\n\n    if (entries === void 0) {\n        return void 0;\n    }\n\n    return entries[name ?? defaultViewName];\n}\n\nfunction getForInstance(object: any, name?: string): RenderInstruction | undefined {\n    if (object) {\n        return getByType(object.constructor, name);\n    }\n\n    return void 0;\n}\n\n/**\n * Provides APIs for creating and interacting with render instructions.\n * @public\n */\nexport const RenderInstruction = Object.freeze({\n    /**\n     * Checks whether the provided object is a RenderInstruction.\n     * @param object - The object to check.\n     * @returns true if the object is a RenderInstruction; false otherwise\n     */\n    instanceOf,\n    /**\n     * Creates a RenderInstruction for a set of options.\n     * @param options - The options to use when creating the RenderInstruction.\n     */\n    create,\n    /**\n     * Creates a template based on a tag name.\n     * @param tagName - The tag name to use when creating the template.\n     * @param attributes - The attributes to apply to the element.\n     * @param content - The content to insert into the element.\n     * @returns A template based on the provided specifications.\n     */\n    createElementTemplate,\n    /**\n     * Creates and registers an instruction.\n     * @param options The options to use when creating the RenderInstruction.\n     * @remarks\n     * A previously created RenderInstruction can also be registered.\n     */\n    register,\n    /**\n     * Finds a previously registered RenderInstruction by type and optionally by name.\n     * @param type - The type to retrieve the RenderInstruction for.\n     * @param name - An optional name used in differentiating between multiple registered instructions.\n     * @returns The located RenderInstruction that matches the criteria or undefined if none is found.\n     */\n    getByType,\n    /**\n     * Finds a previously registered RenderInstruction for the instance's type and optionally by name.\n     * @param object - The instance to retrieve the RenderInstruction for.\n     * @param name - An optional name used in differentiating between multiple registered instructions.\n     * @returns The located RenderInstruction that matches the criteria or undefined if none is found.\n     */\n    getForInstance,\n});\n\n/**\n * Decorates a type with render instruction metadata.\n * @param options - The options used in creating the RenderInstruction.\n * @public\n */\nexport function renderWith(options: Omit<TagNameRenderOptions, \"type\">): ClassDecorator;\n/**\n * Decorates a type with render instruction metadata.\n * @param options - The options used in creating the RenderInstruction.\n * @public\n */\nexport function renderWith(\n    options: Omit<ElementConstructorRenderOptions, \"type\">\n): ClassDecorator;\n/**\n * Decorates a type with render instruction metadata.\n * @param options - The options used in creating the RenderInstruction.\n * @public\n */\nexport function renderWith(options: Omit<TemplateRenderOptions, \"type\">): ClassDecorator;\n/**\n * Decorates a type with render instruction metadata.\n * @param element - The element to use to render the decorated class.\n * @param name - An optional name to differentiate the render instruction.\n * @public\n */\nexport function renderWith(\n    element: Constructable<FASTElement>,\n    name?: string\n): ClassDecorator;\n/**\n * Decorates a type with render instruction metadata.\n * @param template - The template to use to render the decorated class.\n * @param name - An optional name to differentiate the render instruction.\n * @public\n */\nexport function renderWith(template: ContentTemplate, name?: string): ClassDecorator;\nexport function renderWith(value: any, name?: string) {\n    return function (type: Constructable) {\n        if (isFunction(value)) {\n            register({ type, element: value, name });\n        } else if (isFunction(value.create)) {\n            register({ type, template: value, name });\n        } else {\n            register({ type, ...value });\n        }\n    };\n}\n\n/**\n * @internal\n */\nexport class NodeTemplate implements ContentTemplate, ContentView {\n    constructor(public readonly node: Node) {\n        (node as any).$fastTemplate = this;\n    }\n\n    bind(_: any, __: ExecutionContext<any>): void {}\n\n    unbind(): void {}\n\n    insertBefore(refNode: Node): void {\n        refNode.parentNode!.insertBefore(this.node, refNode);\n    }\n\n    remove(): void {\n        this.node.parentNode!.removeChild(this.node);\n    }\n\n    create(): ContentView {\n        return this;\n    }\n}\n\n/**\n * Creates a RenderDirective for use in advanced rendering scenarios.\n * @param binding - The binding expression that returns the data to be rendered. The expression\n * can also return a Node to render directly.\n * @param templateOrTemplateBindingOrViewName - A template to render the data with\n * or a string to indicate which RenderInstruction to use when looking up a RenderInstruction.\n * Expressions can also be provided to dynamically determine either the template or the name.\n * @returns A RenderDirective suitable for use in a template.\n * @remarks\n * If no binding is provided, then a default binding that returns the source is created.\n * If no template is provided, then a binding is created that will use registered\n * RenderInstructions to determine the view.\n * If the template binding returns a string, then it will be used to look up a\n * RenderInstruction to determine the view.\n * @public\n */\nexport function render<TSource = any, TItem = any>(\n    binding?: Binding<TSource, TItem> | Node,\n    templateOrTemplateBindingOrViewName?:\n        | ContentTemplate\n        | string\n        | Binding<TSource, ContentTemplate | string | Node>\n): CaptureType<TSource> {\n    let dataBinding: Binding<TSource>;\n\n    if (binding === void 0) {\n        dataBinding = (source: TSource) => source;\n    } else if (binding instanceof Node) {\n        dataBinding = () => binding;\n    } else {\n        dataBinding = binding;\n    }\n\n    let templateBinding;\n\n    if (templateOrTemplateBindingOrViewName === void 0) {\n        templateBinding = (s: any, c: ExecutionContext) => {\n            const data = dataBinding(s, c);\n\n            if (data instanceof Node) {\n                return (data as any).$fastTemplate ?? new NodeTemplate(data);\n            }\n\n            return instructionToTemplate(getForInstance(data));\n        };\n    } else if (isFunction(templateOrTemplateBindingOrViewName)) {\n        templateBinding = (s: any, c: ExecutionContext) => {\n            let result = templateOrTemplateBindingOrViewName(s, c);\n\n            if (isString(result)) {\n                result = instructionToTemplate(getForInstance(dataBinding(s, c), result));\n            } else if (result instanceof Node) {\n                result = (result as any).$fastTemplate ?? new NodeTemplate(result);\n            }\n\n            return result;\n        };\n    } else if (isString(templateOrTemplateBindingOrViewName)) {\n        templateBinding = (s: any, c: ExecutionContext) => {\n            const data = dataBinding(s, c);\n\n            if (data instanceof Node) {\n                return (data as any).$fastTemplate ?? new NodeTemplate(data);\n            }\n\n            return instructionToTemplate(\n                getForInstance(data, templateOrTemplateBindingOrViewName)\n            );\n        };\n    } else {\n        templateBinding = (_: any, __: ExecutionContext) =>\n            templateOrTemplateBindingOrViewName;\n    }\n\n    return new RenderDirective<TSource>(dataBinding, templateBinding);\n}",null]}